STREAM
  1 #!/usr/bin/env python3
  2 import socket
  3 
  4 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  5 # This can also be accomplished by using s = socket.socket(), because Af_INET, and SOCK_STREAM are defaults.
  6 
  7 ipaddr ='127.0.0.1'
  8 port =54321
  9 
 10 s.connect((ipaddr, port))
 11 
 12 #To send a string as a bytes-like object, add the prefix b to the string. \n is used to go to the next line
 13 s.send(b'Hello\n')
 14 
 15 #It is recommended that the buffersize used with recvfrom is a power of 2 and not a very large number of bits
 16 response, conn = s.recvfrom(1024)
 17 
 18 # In order to receive a message that is sent as bytes-like object, you must decode into utf-8 (default)
 19 print(response.decode())
 20 
 21 s.close()
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 DGRAM  
  1 #!/usr/bin/env python3
  2 
  3 import socket
  4 
  5 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  6 
  7 ipaddr = '127.0.0.1'
  8 port= 54321
  9 
 10 # To send a string as a byte-like object, add the prefix b to the string. \n is used to go to the next line
 11 s.sendto(b'Hello\n',(ipaddr,port))
 12 
 13 # It is recommended that the buffersize used with recvfrom is a power of 2 and not a very large number of bits
 14 response, conn = s.recvfrom(1024)
 15 
 16 # In order to receive a message that is sent as a bytes-like object you must decode into UTF-8 (default)
 17 print(response.decode())
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RAWIPV4SOCKET
#!/usr/bin/env python3

# For building the socket 
import socket

# For system level commands
import sys

# For establishing the packet structure. This will allow direct access to the methods and functions in the struct mode
from struct import *

# Create a raw socket
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()

packet = ''
src_ip = "10.1.0.2"
dst_ip = "10.3.0.2"

# add the IPv4 header information
ip_ver_ihl = 69  #this is putting the decimal conversion off 0x45 for the version and Internet Header length
ip_tos = 0       #this combines the DSCP and ECN fields
ip_len = 0       #the kernel will fill in the actual length of the packet
ip_id = 12345    #this sets the IP identification for the packet
ip_frag = 0      #this sets frag to off
ip_ttl = 64      #this determines the TTL of the packet when leaving the machine
ip_proto = 16    #this sets up the IP proto to 16 (CHAOS). If this was 6 (TCP) or 17 (UDP) additional headers would be required
ip_check = 0     #the kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(srting) will convert and IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(srting) will convert and IP address to a 32 bit binary number

ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)

message + b'This is a message'
packet = ip_header + message  

# Send the packet
s.sendto(packet, (dst_ip, 0)
